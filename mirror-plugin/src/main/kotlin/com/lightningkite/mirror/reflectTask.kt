package com.lightningkite.mirror

import com.lightningkite.mirror.metadata.readPackageFragment
import com.lightningkite.mirror.source.getFileClasses
import com.lightningkite.mirror.source.kotlinNode
import java.io.File
import java.util.jar.JarFile

fun reflectTask(directories: List<File>, jarsToInspect: List<File>) {
    println("Checking source directories: $directories")
    println("Checking jars: $jarsToInspect")

    val requestFiles = directories.asSequence().flatMap {
        it.walkTopDown().filter { it.endsWith("mirror.txt") }
    }.toList()
    if (requestFiles.isEmpty()) return
    val requestedNames = requestFiles.asSequence().flatMap { it.readLines().asSequence().filter { it.isNotBlank() }.drop(2) }.toList()
    val requestPackages = requestedNames.map {
        it.split('.').takeWhile {
            it.firstOrNull()?.isLowerCase() ?: false
        }.joinToString(".")
    }.distinct()

    println("Requested names: $requestedNames")
    println("Requested packages: $requestPackages")

    val sourceDeclarations = directories.asSequence()
            .flatMap { it.walkTopDown() }
            .filter { it.extension == "kt" }
            .filter {
                val text = it.readText()
                if (text.contains("Generated by Lightning Kite's Mirror plugin")) return@filter false
                val textPackage = text.substringAfter("package ").takeWhile { !it.isWhitespace() }
                if (textPackage !in requestPackages) return@filter false
                true
            }
            .flatMap {
                it.kotlinNode().getFileClasses().asSequence()
            }

    val libraryDeclarations = jarsToInspect.asSequence()
            .flatMap {
                val file = JarFile(it)
                file.entries().asSequence()
                        .filter { it.name.endsWith("kotlin_metadata") }
                        .flatMap { file.getInputStream(it).readPackageFragment().read().asSequence() }
            }

    val declarations = (sourceDeclarations + libraryDeclarations)
            .map {
                println(it.qualifiedName)
                it
            }
            .filter { it.qualifiedName in requestedNames }
            .associateBy { it.qualifiedName }

    println("Declarations: ${declarations.map { it.key }}")

    for (file in requestFiles) {
        val lines = file.readLines().asSequence().filter { it.isNotBlank() }.toList()
        val myDeclarations = lines.subList(2, lines.size).mapNotNull { declarations[it] }
        for (decl in myDeclarations) {
            File(file.parentFile, decl.reflectionName + ".kt").writeText(decl.toString())
        }
        val finalFile = DeclarationsFile(
                packageName = lines.getOrNull(0) ?: "com.lightningkite.nopackage",
                functionName = lines.getOrNull(1) ?: "setUpMirror()",
                reflections = myDeclarations.map { it.packageName + "." + it.reflectionName }
        )
        File(file.parentFile, file.nameWithoutExtension + ".kt").writeText(finalFile.toString())
    }
}