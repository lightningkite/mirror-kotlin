package com.lightningkite.mirror.output

import com.lightningkite.mirror.TabWriter
import com.lightningkite.mirror.representation.ReadClassInfo
import com.lightningkite.mirror.representation.ReadClassInfo.Companion.GENERATED_NOTICE
import com.lightningkite.mirror.representation.minimumBound
import com.lightningkite.mirror.representation.useMinimumBound

fun TabWriter.writeAnnotation(classInfo: ReadClassInfo) {
    line("//Generated by Lightning Kite's Mirror plugin")
    line("//$GENERATED_NOTICE")
    line("package ${classInfo.reflectionPackage}")
    line()
    for (import in classInfo.fullImports) {
        line("import $import")
    }
    line()
    line {
        append("data class ")
        append(classInfo.accessName)
        append("(")
    }
    tab {
        classInfo.fields.forEachIndexed { index, field ->
            line {
                append("val ")
                append(field.name)
                append(": ")
                append(field.type.use)
                if (field.default != null) {
                    append(" = ")
                    append(field.default)
                }
                if (index != classInfo.fields.lastIndex) {
                    append(",")
                }
            }
        }
    }
    line(")")
}

fun TabWriter.writeMirror(classInfo: ReadClassInfo) = with(classInfo) {

    line("//Generated by Lightning Kite's Mirror plugin")
    line("//$GENERATED_NOTICE")
    line("package ${classInfo.reflectionPackage}")
    line()
    for (import in classInfo.fullImports) {
        line("import $import")
    }
    line()
    if (typeParameters.isNotEmpty()) {
        line {
            append("class ")
            append(reflectionName)
            append(typeParameters.joinToString(", ", "<", ">") { it.name + ": " + it.projection.useMinimumBound(classInfo) })
            append("(")
        }
        tab {
            typeParameters.forEachIndexed { index, readTypeParameter ->
                line {
                    append("val ")
                    append(readTypeParameter.name)
                    append("Mirror: MirrorType<")
                    append(readTypeParameter.name)
                    append(">")
                    if (index != typeParameters.lastIndex) {
                        append(",")
                    }
                }
            }
        }
        line {
            append(") : MirrorClass<")
            append(classInfo.accessNameWithArguments)
            append(">() {")
        }
        tab {
            line()
            line("companion object {")
            tab {
                line {
                    append("val minimal = ")
                    append(reflectionName)
                    append("(")
                    append(typeParameters.joinToString { it.minimumBound(classInfo).toString() })
                    append(")")
                }
            }
            line("}")
            line()
            line {
                append("override val typeParameters: Array<MirrorType<*>> get() = arrayOf(")
                append(typeParameters.joinToString { it.name + "Mirror" })
                append(")")
            }
        }
    } else {
        line {
            append("object ")
            append(reflectionName)
            append(typeParameters.joinToString { it.name + ": " + it.projection.useMinimumBound(classInfo) })
            append(" : MirrorClass<")
            append(classInfo.accessName)
            append("<")
            append(typeParameters.joinToString { it.name })
            append(">>() {")
        }
    }

    tab {

        line("""@Suppress("UNCHECKED_CAST")""")
        line {
            append("override val kClass: KClass<")
            append(classInfo.accessNameWithArguments)
            append("> get() = ")
            append(classInfo.accessName)
            append("::class as KClass<")
            append(classInfo.accessNameWithArguments)
            append(">")
        }

        line {
            append("override val modifiers: Array<Modifier> get() = arrayOf(")
            append(modifiers.joinToString { "Modifier." + it.name })
            append(")")
        }

        line("override val packageName: String get() = \"${classInfo.packageName}\"")
        line("override val localName: String get() = \"${classInfo.accessName}\"")
        if (classInfo.owner != null) {
            line("override val owningClass: KClass<*>? get() = \"${classInfo.owner}\"")
        }
        if (classInfo.hasCompanion) {
            line("override val companion: Any? get() = ${classInfo.accessName}.Companion")
        }
        if (classInfo.annotations.isNotEmpty()) {
            line {
                append("override val annotations: List<Annotation> = listOf(")
                append(classInfo.annotations.joinToString { it.name + "Impl" + "(" + it.arguments.joinToString() + ")" })
                append(")")
            }
        }

        line()

        for (field in classInfo.fields) {
            line {
                append("val ")
                append(field.fieldName)
                append(": Field<")
                append(field.type.use)
                append("> = Field(")
            }
            tab {
                line("owner = this,")
                line("name = \"${field.name}\",")
                line("type = ${field.type},")
                line("optional = ${field.optional},")
                line("get = { it.${field.name} },")
                if (field.mutable) {
                    line("set = { it, value -> it.${field.name} = value },")
                }
                line {
                    append("annotations = listOf<Annotation>(")
                    append(classInfo.annotations.joinToString { it.name + "Impl" + "(" + it.arguments.joinToString() + ")" })
                    append(")")
                }
            }
            line(")")
            line()
        }

        line {
            append("override val fields: Array<Field<")
            append(", *>> = arrayOf(")
            append(fields.joinToString { it.fieldName })
            append(")")
        }

        line()

        line {
            append("override fun deserialize(decoder: Decoder): ")
            append(classInfo.accessNameWithArguments)
            append(" {")
        }
        tab {
            //Make a place to enter the values
            for (field in fields) {
                line("var ${field.name}_set = false")
                line("var ${field.name}: ${field.type.use}? = null")
            }

            //Retrieve the values

            //Handle defaults
            for ((index, field) in optionalFields.withIndex()) {
                if (field.default != null) {
                    //We have a default calculation?  Awesome!
                    line("if(!${field.name}_set) {")
                    tab {
                        line("${field.name} = ${field.default}")
                    }
                    line("}")
                } else if (field.type.nullable) {
                    //Oh good, let's just use null if it's not there
                } else {
                    //Well... I guess we'll retrieve it by calling the constructor an extra time.
                    line("if(!${field.name}_set) {")
                    tab {
                        val args = requiredFields.asSequence().map { it.name + " = " + it.name } + optionalFields.subList(0, index).asSequence().map { it.name + " = " + it.name }
                        line("${field.name} = (${field.fieldName}.get($accessNameWithBound(${args.joinToString()})) as ${field.type.useMinimumBound(this)})")
                        line {
                            append(field.name)
                            append(" = ")
                            append(field.fieldName)
                            append(".get(")
                            append(accessNameWithArguments)
                            append("(")
                        }
                        tab {
                            val fieldsSoFar = requiredFields + optionalFields.subList(0, index)
                            for((subindex, subfield) in fieldsSoFar.withIndex()){
                                line{
                                    append(subfield.name)
                                    append(" = ")
                                    append(subfield.name)
                                    if(subindex != fieldsSoFar.lastIndex){
                                        append(",")
                                    }
                                }
                            }
                        }
                        line("))")
                    }
                    line("}")
                }
            }

            //Construct the object
            line {
                append(accessNameWithArguments)
                append("(")
            }
            tab {
                for((index, field) in fields.withIndex()){
                    line{
                        append(field.name)
                        append(" = ")
                        append(field.name)
                        if(index != fields.lastIndex){
                            append(",")
                        }
                    }
                }
            }
            line(")")

            /*
    fun generateConstructor(): String {
        if (modifiers.contains(Modifier.Interface) || modifiers.contains(Modifier.Abstract) || modifiers.contains(Modifier.Sealed) || enumValues != null) {
            return """
                    |    override fun construct(map: Map<String, Any?>): $accessNameWithBound = throw NotImplementedError()
                    """.trimMargin()
        }
        if (modifiers.contains(Modifier.Object)) {
            return """
                    |    override fun construct(map: Map<String, Any?>): $accessNameWithBound = $accessName
                    """.trimMargin()
        }
        return """
            |    override fun construct(map: Map<String, Any?>): $accessNameWithBound {
            |        //Gather variables
            |        ${
        requiredFields
                .joinToString("\n        ") {
                    "val ${it.name}:${it.type.useMinimumBound(this)} = map[\"${it.name}\"] as ${it.type.useMinimumBound(this)}"
                }
            }
            |        //Handle the optionals
            |        ${
        optionalFields
                .withIndex()
                .joinToString("\n        ") { (index, it) ->
                    if (it.default != null) {
                        //We have a default calculation?  Awesome!
                        "val ${it.name}:${it.type.useMinimumBound(this)} = map[\"${it.name}\"] as? ${it.type.useMinimumBound(this)} ?: ${it.default}"
                    } else if (it.type.nullable) {
                        //Oh good, let's just use null if it's not there
                        "val ${it.name}:${it.type.useMinimumBound(this)} = map[\"${it.name}\"] as ${it.type.useMinimumBound(this)}"
                    } else {
                        //Well... I guess we'll retrieve it by calling the constructor an extra time.
                        val args = requiredFields.asSequence().map { it.name + " = " + it.name } + optionalFields.subList(0, index).asSequence().map { it.name + " = " + it.name }
                        "val ${it.name}:${it.type.useMinimumBound(this)} = map[\"${it.name}\"] as? ${it.type.useMinimumBound(this)} ?: (${it.fieldName}.get($accessNameWithBound(${args.joinToString()})) as ${it.type.useMinimumBound(this)})"
                    }
                }
        }
            |        //Finally do the call
            |        return $accessNameWithBound(
            |            ${fields.joinToString(",\n            ") { it.name + " = " + it.name }}
            |        )
            |    }
            """.trimMargin()*/
        }
        line("}")
    }

    line("}")
    /*
    override fun deserialize(decoder: Decoder): Pair<A, B> {
        var first: A? = null
        var second: B? = null
        decoder.beginStructure(this, typeA, typeB).apply {
            loop@ while (true) {
                when (decodeElementIndex(this@PairClassInfo)) {
                    CompositeDecoder.READ_ALL -> {
                        first = decodeSerializableElement(this@PairClassInfo, 0, typeA)
                        second = decodeSerializableElement(this@PairClassInfo, 1, typeB)
                        break@loop
                    }
                    CompositeDecoder.READ_DONE -> break@loop
                    0 -> first = decodeSerializableElement(this@PairClassInfo, 0, typeA)
                    1 -> second = decodeSerializableElement(this@PairClassInfo, 1, typeB)
                    else -> {
                    }
                }
            }
            endStructure(this@PairClassInfo)
        }
        return Pair(
                first = first as A,
                second = second as B
        )
    }

    override fun serialize(encoder: Encoder, obj: Pair<A, B>) {
        encoder.beginStructure(this, typeA, typeB).apply {
            encodeSerializableElement(this@PairClassInfo, 0, typeA, obj.first)
            encodeSerializableElement(this@PairClassInfo, 1, typeB, obj.second)
            endStructure(this@PairClassInfo)
        }
    }
}
    */
}