//Generated by Lightning Kite's Mirror plugin
package com.lightningkite.kotlinx.persistence

import com.lightningkite.kotlinx.reflection.ExternalReflection
import com.lightningkite.mirror.info.*
import kotlin.reflect.KClass

@Suppress("RemoveExplicitTypeArguments", "UNCHECKED_CAST")
object ChangeEventClassInfo : ClassInfo<ChangeEvent<*, *>> {

    override val kClass: KClass<ChangeEvent<*, *>> = ChangeEvent::class
    override val modifiers: List<ClassInfo.Modifier> = listOf(ClassInfo.Modifier.Data)

    override val implements: List<Type<*>> = listOf()

    override val packageName: String = "com.lightningkite.kotlinx.persistence"
    override val owner: KClass<*>? = null
    override val ownerName: String? = null

    override val name: String = "ChangeEvent"
    override val annotations: List<AnnotationInfo> = listOf(AnnotationInfo("ExternalReflection", listOf<Any?>()))
    override val enumValues: List<ChangeEvent<*, *>>? = null

    object Fields {
        val item = SerializedFieldInfo<ChangeEvent<*, *>, Model<Any?>>(ChangeEventClassInfo, "item", Type<Model<Any?>>(Model::class as KClass<Model<Any?>>, listOf(), false), false, { it.item as Model<Any?> }, listOf())
        val type = SerializedFieldInfo<ChangeEvent<*, *>, ChangeEvent.Type>(ChangeEventClassInfo, "type", Type<ChangeEvent.Type>(ChangeEvent.Type::class as KClass<ChangeEvent.Type>, listOf(), false), false, { it.type as ChangeEvent.Type }, listOf())
    }

    override val fields: List<SerializedFieldInfo<ChangeEvent<*, *>, *>> = listOf(Fields.item, Fields.type)

    override fun construct(map: Map<String, Any?>): ChangeEvent<Model<Any?>, Any?> {
        //Gather variables
        val item: Model<Any?> = map["item"] as Model<Any?>
        val type: ChangeEvent.Type = map["type"] as ChangeEvent.Type
        //Handle the optionals

        //Finally do the call
        return ChangeEvent<Model<Any?>, Any?>(
                item = item,
                type = type
        )
    }

}