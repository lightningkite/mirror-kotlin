//Generated by Lightning Kite's Mirror plugin
//AUTOMATICALLY GENERATED AND WILL BE OVERRIDDEN IF THIS MESSAGE IS PRESENT
package com.lightningkite.mirror.test

import kotlinx.serialization.Serializable
import com.lightningkite.mirror.info.*
import kotlin.reflect.KClass

@Suppress("RemoveExplicitTypeArguments", "UNCHECKED_CAST", "USELESS_CAST")
object TreeClassInfo: ClassInfo<Tree> {

    override val kClass: KClass<Tree> = Tree::class
    override val modifiers: List<ClassInfo.Modifier> = listOf(ClassInfo.Modifier.Data)
    override val companion: Any? get() = null

    override val implements: List<Type<*>> = listOf()

    override val packageName: String = "com.lightningkite.mirror.test"
    override val owner: KClass<*>? = null
    override val ownerName: String? = null

    override val name: String = "Tree"
    override val annotations: List<AnnotationInfo> = listOf(AnnotationInfo("@Serializable", listOf()))
    override val enumValues: List<Tree>? = null

    val fieldName = FieldInfo<Tree, String>(this, "name", Type<String>(String::class, listOf(), false), false, { it.name as String}, listOf())
    val fieldLeft = FieldInfo<Tree, Tree?>(this, "left", Type<Tree?>(Tree::class, listOf(), true), true, { it.left as Tree?}, listOf())
    val fieldRight = FieldInfo<Tree, Tree?>(this, "right", Type<Tree?>(Tree::class, listOf(), true), true, { it.right as Tree?}, listOf())

    override val fields:List<FieldInfo<Tree, *>> = listOf(fieldName, fieldLeft, fieldRight)

    override fun construct(map: Map<String, Any?>): Tree {
        //Gather variables
        val name:String = map["name"] as String
        //Handle the optionals
        val left:Tree? = map["left"] as? Tree? ?: null
        val right:Tree? = map["right"] as? Tree? ?: null
        //Finally do the call
        return Tree(
            name = name,
            left = left,
            right = right
        )
    }

}